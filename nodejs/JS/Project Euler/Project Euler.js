http://euler.synap.co.kr/

=================================================================================================

Problem 100
출제 일시 : 2012-07-05 17:33:09

파란 공 15개와 빨간 공 6개가 들어있는 상자에서 무작위로 두 개의 공을 꺼냈을 때, 두 개가 모두 파란색일 확률은 (15/21) × (14/20) = 1/2 입니다.

이렇게 무작위로 꺼낸 공 두 개가 모두 파란색일 확률이 정확히 50%가 되는 다음 번째 공의 배합은 파란 공 85개와 빨간 공 35개일 때입니다.

파란 공과 빨간 공을 합해서 모두 10^12 = 1,000,000,000,000 을 넘는 배합 중에서 위와 같은 확률을 가지면서 공의 수가 최소인 경우를 찾고, 이 때 파란 공은 모두 몇 개가 되는지 구하세요.

{ // Problem 100 - 756872327473 + 313506783024 = 1070379110497

/* 찌끄레기 풀이

2(ax)^2 = x^2
a = sqrt(2) / 2 ;

정수 n이 1e12 < n를 만족하고
1 < k < n, 2 * k * ( k - 1) = n * ( n - 1), 두 조건을 만족하는 k의 근사값은 n * sqrt(2) / 2 이다.
이때 정수 k 의 최소값을 여러가지 방법으로 찾는다.

풀이 1
직접 곱하고 나눠서 구한다

- PL의 한계 발생

풀이 2
n = 0.5 + Math.sqrt(2*k*(k-1) + 0.25);
를 만족하게 된다.
따라서 1씩 증가시켜 가며 구한다.

- Complexity 쩔음, PL의 한계 발생

풀이 3
1부터 sqrt(k)까지의 소수를 찾아 일일히 나누면서 소인수분해를 하고,
이를 이용해 분모가 2만 남도록 한다.

- Complexity 쩔음

풀이 4
(n, k), (n, k-1), (n-1, k) 각각을 대상으로 최대공약수를 구해서
약분을 수행하여 분모가 2만 남도록 한다

- 3보다는 훨씬 빠름(공약수 구하는게 소인수분해보다 훨씬 쉽다), but 여전히 느려터짐
*/

/* 정석 풀이 from http://www.alpertron.com.ar/METHODS.HTM
풀이 5
디오판토스 2차방정식의 일반해를 구해서 푼다.
ㅠㅠ

식 : Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0

1. Linear case: A = B = C = 0.
2. Simple hyperbolic case: A = C = 0; B != 0.
3. Elliptical case: B2 - 4AC < 0.
4. Parabolic case: B2 - 4AC = 0.
5. Hyperbolic case: B2 - 4AC > 0.
*/

/* 1. Linear case: A = B = C = 0

1. Linear case: A = B = C = 0
식 : Dx + Ey + F = 0

1) D = 0 & E = 0 -> F = 0 -> All x, All y.
If D = 0 and E = 0 there will be solutions only if F = 0. In this case all values of x and y are solutions.

2) D = 0 & E != 0 -> All x, y = - F / E
If D = 0 and E != 0 we have:
Ey + F = 0 => y = -F/E, x = any integer.
This means that there will be solutions if and only if F is a multiple of E.

3) D != 0 & E = 0 -> x = - F / D, All y
If D != 0 and E = 0 we have:
Dx + F = 0 => x = -F/D, y = any integer.
This means that there will be solutions if and only if F is a multiple of D.

4) D != & E != 0			******************** 중요 ************************
If D != 0 and E != 0 the situation is slighty more complicated:
Let g = gcd(D, E). Since both D and E are multiple of g, the expression Dx + Ey will be also a multiple of g for any integer value of x and y, so if F is not a multiple of g the equation has no solutions.
	D, E 의 최대공약수가 F를 나눌 수 없다면 해가 없다.
If F is multiple of g we can divide all three coefficients by g thus obtaining:
dx + ey = -f (where d=D/g, e=E/g and f=F/g). We will use now the Extended Euclid's Algorithm that can be used to find integers u' and v' such that uu'+vv' = ±gcd(u, v) (where the sign depends on the sign of d and e and the exact implementation of the algorithm).

We can let u = d, v = e. Once the values of u' and v' are found so that du'+ev' = ±1 (since gcd(d, e)=1) we can multiply the equation by -f to obtain:

du'+ev' = ±1 => d(±fu')+e(±fv') = -f => d(±fu')+det+e(±fv')-det = -f => d(et±fu')+e(-dt±fv') = f

So the general solution set is:

x = et ± fu'
y = -dt ± fv'
t = any integer


*/

var now=performance.now();
// Diophantine Equation 2차방정식 일반해 푸는 함수
function dio(A, B, C, D, E, F, seq){
	var results = [];
	// Linear case
	if ( A == 0 && B == 0 && C == 0 ){
		if ( D == 0 && E == 0 ) {
			if ( F == 0 ) return "All values of x, y are solutions";
			else return "There is no answer";
		} else if ( D == 0 && 
	}
}
}

=================================================================================================

Problem 2
출제 일시 : 2012-01-03 19:11:35

피보나치 수열의 각 항은 바로 앞의 항 두 개를 더한 것이 됩니다. 1과 2로 시작하는 경우 이 수열은 아래와 같습니다.
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
짝수이면서 4백만 이하인 모든 항을 더하면 얼마가 됩니까?

{ // Problem 2 - 4613732
풀이
특징
1. 짝수판별 불필요
2. 낮은 iteration 횟수
3. integer variable 4개

짝수+홀수 = 홀수, 홀수+홀수 = 짝수.
따라서 피보나치에서는 3번마다 한번 짝수가 발생한다.

an이 짝수라 두었을때 다음 짝수인 an+3의 점화식은 아래와 같다.

an+3 = an+2 + an+1
= 2an+1 + an
= 3an + 2an-1

an+3 - an - an-1 = 2an + an-1
=an+2

따라서, an+2 = 2an + an-1

// JavaScript
var sum=0, a=b=1, c=2;
while (c < 4000001){
	sum+=c;
	a+=2*c;
	c+=2*(b+c);
	b=a;
}
console.log(sum);

}
=================================================================================================



Problem 3
출제 일시 : 2012-01-03 19:11:35

어떤 수를 소수의 곱으로만 나타내는 것을 소인수분해라 하고, 이 소수들을 그 수의 소인수라고 합니다.
예를 들면 13195의 소인수는 5, 7, 13, 29 입니다.
600851475143의 소인수 중에서 가장 큰 수를 구하세요.

{ // Problem 3 - 6857
// JavaScript
// 바보짓
var x=quotient=600851475143, prime=[2], flag=false, result=[];
for ( i = 2 ; i < x / i ; i++){
	flag = false;
	for ( j = 0 ; j < prime.length ; j++){
		if ( i / prime[j] < prime[j] ) break;
		if ( i % prime[j] == 0 ) {
			flag = true;
			break;
		}
	}
	if (!flag){
		prime.push(i);
		if ( quotient % i == 0 ) {
			result.push(i);
			quotient /= i;
			i--;
		}
		if ( quotient == 1){
			break;
		}
	}
}
console.log(result[result.length-1]);


바보짓했네요
멍청하게 소수판별하고 있었다니...
무식하게 2부터 쭉 나누기 반복하면 알아서 소수 아닌 숫자는 커트됩니다.
나누어 떨어진다면 동일한 숫자로 다시 나누어 줍니다.
이렇게하면 소인수분해가 완벽하게 됩니다.

소수판별 함수를 사용하면 그것만으로 상당한 O(n^2) complexity가 발생하기 때문에,
O(n)인 아래의 코드가 효율적입니다.

var x=quotient=600851475143, result=1;
for ( i = 2 ; quotient > 1 && i > x ; i++)
	if ( !(quotient % i) ) {
		result = i;
		quotient /= i--;
	}
console.log(result);

}
================================================================================



Problem 4
출제 일시 : 2012-01-03 19:11:35

앞에서부터 읽을 때나 뒤에서부터 읽을 때나 모양이 같은 수를 대칭수(palindrome)라고 부릅니다.
두 자리 수를 곱해 만들 수 있는 대칭수 중 가장 큰 수는 9009 (= 91 × 99) 입니다.
세 자리 수를 곱해 만들 수 있는 가장 큰 대칭수는 얼마입니까?


{ // Problem 4 - 906609
// JavaScript

// y=x(n-x) 에서 y의 최대값은 x=n/2일때를 이용한 boundary 계산
// k = x + y 에서 k를 줄여나가면서 찾는다.
// 매 k마다 x의 시작점은 k/2이다.
// 어떤 점 (m, n)에서 palindrome이면, x + y = m + n 과 xy = mn 사이만 스캔한다.

// toString
var now = performance.now();
var max = 1E3 - 1, min = 1E2 - 1, result = 1, cnt = 0;
for (var i = max; i > min && result <= i * i; i--)
	for (var m = n = i, flag = true, text, k; m <= max && n > min && result <= m * n; flag ? m++ : n--, flag = !flag, cnt++) {
		for (k = 0, text = (m * n).toString(); k < text.length / 2 && text[k] == text[text.length - 1 - k]; k++);
		if (k >= text.length / 2)
			result = m * n;
	}
console.log("Answer : " + result);
console.log("Exec Time : " + (performance.now() - now));
console.log("Count of palindrome check : " + cnt);


// reverse number
// JS에서 integer division 구현 : ~~(a/b) or (a/b)>>0
var now = performance.now();
var max = 1E3 - 1, min = 1E2 - 1, result = 1, cnt = 0;
for (var i = max; i > min && result <= i * i; i--)
	for (var m = n = i, flag = true; m <= max && n > min && result <= m * n; flag ? m++ : n--, flag = !flag, cnt++) {
		for (var k = n * m, reverse = 0; k; reverse = reverse * 10 + k % 10, k = (k / 10) >> 0);
		if (reverse == n * m)
			result = m * n;
	}
console.log("Answer : " + result);
console.log("Exec Time : " + (performance.now() - now));
console.log("Count of palindrome check : " + cnt);


// minifified code
// toString
a=1E3-1,b=1E2-1,r=1;for(i=a;i>b&&r<=i*i;i--)
for(m=n=i,f=true;m<=a&&n>b&&r<=m*n;f?m++:n--,f=!f){for(k=0,t=(m*n).toString();k<t.length/2&&t[k]==t[t.length-1-k];k++);if(k>=t.length/2)r=m*n;}

// reverse number
a=1E3-1,b=1E2-1,r=1;for(i=a;i>b&&r<=i*i;i--)
for(m=n=i,f=true;m<=a&&n>b&&r<=m*n;f?m++:n--,f=!f){for(k=n*m,v=0;k;v=v*10+k%10,k=(k/10)>>0);if(v==n*m)r=m*n;}

}

================================================================================

Problem 5
출제 일시 : 2012-01-03 19:11:35

1 ~ 10 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 2520입니다.
그러면 1 ~ 20 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 얼마입니까?

{ // Problem 5 - 232792560
범위내의 모든 소수를 구하고, 최대값보다 작은 소수들의 제곱수를 구한다.
해서, 모두 곱한다.

// JavaScript
prime=[2], result = 1;
for ( var i = 3 ; i < 21 ; i+=2){
	flag = false;
	for ( var j = 0 ; j < prime.length && prime[j] <= Math.sqrt(i) ; j++)
		if ( i % prime[j] == 0 ) {
			flag = true;
			break;
		}
	if (!flag) prime.push(i);
}
for ( var i = 0 ; i < prime.length ; i++){
	product = 1;
	while ( product < 21 ) product *= prime[i];
	result *= product / prime[i];
}
console.log(result);

}


================================================================================

Problem 6
출제 일시 : 2012-01-03 19:11:35

1부터 10까지 자연수를 각각 제곱해 더하면 다음과 같습니다 (제곱의 합).
12 + 22 + ... + 102 = 385

1부터 10을 먼저 더한 다음에 그 결과를 제곱하면 다음과 같습니다 (합의 제곱).
(1 + 2 + ... + 10)2 = 552 = 3025

따라서 1부터 10까지 자연수에 대해 "합의 제곱"과 "제곱의 합" 의 차이는 3025 - 385 = 2640 이 됩니다.
그러면 1부터 100까지 자연수에 대해 "합의 제곱"과 "제곱의 합"의 차이는 얼마입니까?

{ // Problem 6 - 25164150

∑k^2 = 1/6 * n(n+1)(2n+1)
(∑k)^2 = (1/2 * n(n+1))^2
(∑k)^2-∑k^2 = 1/12 * n * (n-1) * (n+1) * (3*n+2)

console.log(function(n){return n * (n-1) * (n+1) * (3*n+2) / 12;}(100))

}

================================================================================


Problem 7
출제 일시 : 2012-01-03 19:11:35

소수를 크기 순으로 나열하면 2, 3, 5, 7, 11, 13, ... 과 같이 됩니다.
이 때 10,001번째의 소수를 구하세요.


{ // Problem 7 - 104743
// JavaScript
var prime=[2], flag;
for ( var i = 3 ; prime.length < 10001 ; i+=2){
	flag = false;
	for ( var j = 0 ; j < prime.length && prime[j] <= Math.sqrt(i) ; j++)
		if ( i % prime[j] == 0 ) {
			flag = true;
			break;
		}
	if (!flag) prime.push(i);
}
console.log(prime[10000]);

}

================================================================================


Problem 8
출제 일시 : 2012-01-03 19:11:35

다음은 연속된 1000자리 숫자입니다 (읽기 좋게 50자리씩 잘라놓음).

73167...
여기서 붉게 표시된 71112의 경우 7, 1, 1, 1, 2 각 숫자를 모두 곱하면 14가 됩니다.
이런 식으로 맨 처음 (7 × 3 × 1 × 6 × 7 = 882) 부터 맨 끝 (6 × 3 × 4 × 5 × 0 = 0) 까지 5자리 숫자들의 곱을 구할 수 있습니다.
이렇게 구할 수 있는 5자리 숫자의 곱 중에서 가장 큰 값은 얼마입니까?

{ // Problem 8 - 40824

매번 5개의 숫자를 곱하는건 cost 낭비입니다.
5개 중에 0이 있는 경우는 바로바로 패스하도록 하고,
그렇지 않을 경우 미리 곱해져있는 결과를 첫번째 원소로 나누고, 여섯번째 원소를 곱하면
최소한의 연산만으로 다음 세트의 곱을 얻을 수 있습니다.
dynamic programming 짱짱툴.

// JavaScript
input = "73167176531330624919225119674426574742355349194934" +
"96983520312774506326239578318016984801869478851843" +
"85861560789112949495459501737958331952853208805511" +
"12540698747158523863050715693290963295227443043557" +
"66896648950445244523161731856403098711121722383113" +
"62229893423380308135336276614282806444486645238749" +
"30358907296290491560440772390713810515859307960866" +
"70172427121883998797908792274921901699720888093776" +
"65727333001053367881220235421809751254540594752243" +
"52584907711670556013604839586446706324415722155397" +
"53697817977846174064955149290862569321978468622482" +
"83972241375657056057490261407972968652414535100474" +
"82166370484403199890008895243450658541227588666881" +
"16427171479924442928230863465674813919123162824586" +
"17866458359124566529476545682848912883142607690042" +
"24219022671055626321111109370544217506941658960408" +
"07198403850962455444362981230987879927244284909188" +
"84580156166097919133875499200524063689912560717606" +
"05886116467109405077541002256983155200055935729725" +
"71636269561882670428252483600823257530420752963450";

product = 1, zeroPos = -1, result = 0;
for (i = 0 ; i < input.length ; i++){
	if (input[i] == 0){
		zeroPos = i;
		product = 1;
		continue;
	}
	if (zeroPos < i) product *= input[i];
	if (zeroPos + 5 < i) {
		product /= input[i-5];
		if (product > result) result = product;
	}
}
console.log(result);

}


================================================================================


Problem 9
출제 일시 : 2012-01-03 19:11:35

세 자연수 a, b, c 가 피타고라스 정리 a2 + b2 = c2 를 만족하면 피타고라스 수라고 부릅니다 (여기서 a < b < c ).
예를 들면 32 + 42 = 9 + 16 = 25 = 52이므로 3, 4, 5는 피타고라스 수입니다.
a + b + c = 1000 인 피타고라스 수 a, b, c는 한 가지 뿐입니다. 이 때, a × b × c 는 얼마입니까?

{ // Problem 9 - 31875000	
a + b + sqrt(a^2 + b^2) = 1000
a가 가질 수 있는 최대값은 b = 0 일때, 즉 a = 500 ( c = 500 )
그러나 a > b 인 경우는 의미가 없으므로, a = b인 경우까지만 탐색
따라서, a < 1000 - 500 * sqrt(2)

a에 대한 b의 일반식은
b = 1000 * ( 500 - a ) / ( 1000 - a )
이때 b, c가 정수인 경우를 찾으면 됨.

b, c를 구함에 있어 floating point number 연산을 최소화하는 것이 중점

// JavaScript
for (a = 1 ; a < 1000 - 500 * Math.sqrt(2) ; a++){
	if ((1000 * (500 - a)) % (1000 - a) != 0) continue;
	b = 1000 * (500 - a) / (1000 - a);
	c = Math.sqrt(a*a + b*b);
	if (parseFloat(c) == parseInt(c)) {
		console.log(a*b*c);
		break;
	}
}
}



================================================================================

Problem 10
출제 일시 : 2012-01-03 19:11:35

10 이하의 소수를 모두 더하면 2 + 3 + 5 + 7 = 17 이 됩니다.
이백만(2,000,000) 이하 소수의 합은 얼마입니까?

{ // Problem 10 - 142913828922 - 66413ms
// JavaScript
now = performance.now();
var sum = 2, prime=[sum], flag;
for ( var i = 3 ; i < 2E6 ; i+=2){
	flag = false;
	for ( var j = 0 ; j < prime.length && prime[j] <= Math.sqrt(i) ; j++)
		if ( i % prime[j] == 0 ) {
			flag = true;
			break;
		}
	if (!flag) {
		prime.push(i);
		sum += i;
	}
}
console.log(sum);
console.log(performance.now()-now);

}



================================================================================

Problem 11
출제 일시 : 2012-01-03 19:11:35

아래와 같은 20×20 격자가 있습니다.
08 02 22 97 38 ...
위에서 대각선 방향으로 연속된 붉은 숫자 네 개의 곱은 26 × 63 × 78 × 14 = 1788696 입니다.
그러면 수평, 수직, 또는 대각선 방향으로 연속된 숫자 네 개의 곱 중 최대값은 얼마입니까?

{ // Problem 11 - 70600674 = 89*94*97*87
8번 문제의 확장입니다.
이번 문제는 dynamic programming을 얼마나 잘 활용하는가가 핵심이 되겠습니다.
매번 4개의 숫자를 다 곱하면 입력받는 크기가 커질 경우 골치아프게 됩니다.

boundary handling, 0이 나타나는 경우를 잘 고려하면 좋은 알고리즘을 만들 수 있다고 봅니다.

출제자의 의도와 잘 맞게, 정답은 가장 구현난이도가 높은 우상향에서 출현했습니다.

// JavaScript
input = [
[08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08], 
[49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00], 
[81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65], 
[52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91], 
[22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80], 
[24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50], 
[32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70], 
[67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21], 
[24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72], 
[21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95], 
[78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92], 
[16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57], 
[86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58], 
[19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40], 
[04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66], 
[88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69], 
[04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36], 
[20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16], 
[20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54], 
[01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]
];

result = 0;
// horizontal
for (i = 0 ; i < 20 ; i++){
	zeroPos = -1, product = 1;
	for (j=0 ; j < 20 ; j++){
		if (input[i][j] == 0){
			zeroPos = j;
			product = 1;
			continue;
		}
		if (zeroPos < j) product *= input[i][j];
		if (zeroPos + 4 < j) {
			product /= input[i][j-4];
			if (product > result) result = product;
		}
	}
}
// vertical
for (j = 0 ; j < 20 ; j++){
	zeroPos = -1, product = 1;
	for (i=0 ; i < 20 ; i++){
		if (input[i][j] == 0){
			zeroPos = i;
			product = 1;
			continue;
		}
		if (zeroPos < i) product *= input[i][j];
		if (zeroPos + 4 < i) {
			product /= input[i-4][j];
			if (product > result) result = product;
		}
	}
}
// diagonal upper left to lower right
for (i = -20 ; i < 20 ; i++){
	zeroPos = -1, product = 1;
	for (j=0 ; j < 20 ; j++){
		if (i+j < 0) continue;
		if (i+j > 19) break;
		if (i+j==0) zeroPos = j-1;
		if (input[i+j][j] == 0){
			zeroPos = j;
			product = 1;
			continue;
		}
		if (zeroPos < j) product *= input[i+j][j];
		if (zeroPos + 4 < j) {
			product /= input[i+j-4][j-4];
			if (product > result) result = product;
		}
	}
}
// diagonal upper right to lower left
for (i = 0 ; i < 40 ; i++){
	zeroPos = -1, product = 1;
	for (j=0 ; j < 20 ; j++){
		if (i-j > 19) continue;
		if (i-j < 0) break;
		if (i-j==19) zeroPos = j-1;
		if (input[i-j][j] == 0){
			zeroPos = j;
			product = 1;
			continue;
		}
		if (zeroPos < j) product *= input[i-j][j];
		if (zeroPos + 4 < j) {
			product /= input[i-j+4][j-4];
			if (product > result) result = product;
		}
	}
}
console.log(result);

}


================================================================================


Problem 12
출제 일시 : 2012-01-03 19:11:35

1부터 n까지의 자연수를 차례로 더하여 구해진 값을 삼각수라고 합니다.
예를 들어 7번째 삼각수는 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28이 됩니다.
이런 식으로 삼각수를 구해 나가면 다음과 같습니다.
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
이 삼각수들의 약수를 구해봅시다.
 1: 1
 3: 1, 3
 6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
위에서 보듯이, 5개 이상의 약수를 갖는 첫번째 삼각수는 28입니다.
그러면 500개 이상의 약수를 갖는 가장 작은 삼각수는 얼마입니까?

{ // Problem 12 - 76576500 = 2^2 * 3^2 * 5^3 * 7 * 11 * 13 * 17 => 약수 576개
n번째 삼각수 = n * ( n + 1) / 2


// 무식하게 1부터 sqrt(tri)까지 나눠서 *2 해서 약수 갯수 구하기 - 63622ms
now = performance.now();
tri = 0, divisors = 0;
for (i = 1 ; divisors < 500 ; i++){
	tri += i, divisors = 0;
	for ( j = 1; j < Math.sqrt(tri) ; j++){
		if (tri % j == 0) divisors+=2;
	}
	if (j == Math.sqrt(tri)) divisors++;
}
console.log(tri);
console.log(performance.now() - now);

// n, n+1은 서로소 이용 / 2 해주면 약수 갯수 나옴, dynamic programming 적용 - 986ms
now = performance.now();
divisors = 0, div1 = 1;
for (i = 2 ; divisors < 500 ; i++){
	k = i % 2 ? i : i / 2;
	div2 = 0;
	for ( j = 1; j < Math.sqrt(k) ; j++){
		if (k % j == 0) div2+=2;
	}
	if (j == Math.sqrt(k)) div2++;
	divisors = div1*div2;
	div1 = div2;
}
console.log((i-1)*(i-2)/2);
console.log(performance.now() - now);

// JavaScript
}


================================================================================

Problem 13
출제 일시 : 2012-01-03 19:11:35

아래에 50자리 숫자가 100개 있습니다. 이것을 모두 더한 값의 첫 10자리는 얼마입니까?

{ // Problem 13 - 5537376230
해당 PL이 허용하는 범위 내에서 뒷자리부터 끊어서 연산한다.
편의상 10자리씩 끊는다. 이후 몫을 다음 자릿수 연산에 더하면 된다.
앞의 12자리만 끊어서 더해도 끝.

// JavaScript
input = [
"37107287533902102798797998220837590246510135740250",
"46376937677490009712648124896970078050417018260538",
"74324986199524741059474233309513058123726617309629",
"91942213363574161572522430563301811072406154908250",
"23067588207539346171171980310421047513778063246676",
"89261670696623633820136378418383684178734361726757",
"28112879812849979408065481931592621691275889832738",
"44274228917432520321923589422876796487670272189318",
"47451445736001306439091167216856844588711603153276",
"70386486105843025439939619828917593665686757934951",
"62176457141856560629502157223196586755079324193331",
"64906352462741904929101432445813822663347944758178",
"92575867718337217661963751590579239728245598838407",
"58203565325359399008402633568948830189458628227828",
"80181199384826282014278194139940567587151170094390",
"35398664372827112653829987240784473053190104293586",
"86515506006295864861532075273371959191420517255829",
"71693888707715466499115593487603532921714970056938",
"54370070576826684624621495650076471787294438377604",
"53282654108756828443191190634694037855217779295145",
"36123272525000296071075082563815656710885258350721",
"45876576172410976447339110607218265236877223636045",
"17423706905851860660448207621209813287860733969412",
"81142660418086830619328460811191061556940512689692",
"51934325451728388641918047049293215058642563049483",
"62467221648435076201727918039944693004732956340691",
"15732444386908125794514089057706229429197107928209",
"55037687525678773091862540744969844508330393682126",
"18336384825330154686196124348767681297534375946515",
"80386287592878490201521685554828717201219257766954",
"78182833757993103614740356856449095527097864797581",
"16726320100436897842553539920931837441497806860984",
"48403098129077791799088218795327364475675590848030",
"87086987551392711854517078544161852424320693150332",
"59959406895756536782107074926966537676326235447210",
"69793950679652694742597709739166693763042633987085",
"41052684708299085211399427365734116182760315001271",
"65378607361501080857009149939512557028198746004375",
"35829035317434717326932123578154982629742552737307",
"94953759765105305946966067683156574377167401875275",
"88902802571733229619176668713819931811048770190271",
"25267680276078003013678680992525463401061632866526",
"36270218540497705585629946580636237993140746255962",
"24074486908231174977792365466257246923322810917141",
"91430288197103288597806669760892938638285025333403",
"34413065578016127815921815005561868836468420090470",
"23053081172816430487623791969842487255036638784583",
"11487696932154902810424020138335124462181441773470",
"63783299490636259666498587618221225225512486764533",
"67720186971698544312419572409913959008952310058822",
"95548255300263520781532296796249481641953868218774",
"76085327132285723110424803456124867697064507995236",
"37774242535411291684276865538926205024910326572967",
"23701913275725675285653248258265463092207058596522",
"29798860272258331913126375147341994889534765745501",
"18495701454879288984856827726077713721403798879715",
"38298203783031473527721580348144513491373226651381",
"34829543829199918180278916522431027392251122869539",
"40957953066405232632538044100059654939159879593635",
"29746152185502371307642255121183693803580388584903",
"41698116222072977186158236678424689157993532961922",
"62467957194401269043877107275048102390895523597457",
"23189706772547915061505504953922979530901129967519",
"86188088225875314529584099251203829009407770775672",
"11306739708304724483816533873502340845647058077308",
"82959174767140363198008187129011875491310547126581",
"97623331044818386269515456334926366572897563400500",
"42846280183517070527831839425882145521227251250327",
"55121603546981200581762165212827652751691296897789",
"32238195734329339946437501907836945765883352399886",
"75506164965184775180738168837861091527357929701337",
"62177842752192623401942399639168044983993173312731",
"32924185707147349566916674687634660915035914677504",
"99518671430235219628894890102423325116913619626622",
"73267460800591547471830798392868535206946944540724",
"76841822524674417161514036427982273348055556214818",
"97142617910342598647204516893989422179826088076852",
"87783646182799346313767754307809363333018982642090",
"10848802521674670883215120185883543223812876952786",
"71329612474782464538636993009049310363619763878039",
"62184073572399794223406235393808339651327408011116",
"66627891981488087797941876876144230030984490851411",
"60661826293682836764744779239180335110989069790714",
"85786944089552990653640447425576083659976645795096",
"66024396409905389607120198219976047599490197230297",
"64913982680032973156037120041377903785566085089252",
"16730939319872750275468906903707539413042652315011",
"94809377245048795150954100921645863754710598436791",
"78639167021187492431995700641917969777599028300699",
"15368713711936614952811305876380278410754449733078",
"40789923115535562561142322423255033685442488917353",
"44889911501440648020369068063960672322193204149535",
"41503128880339536053299340368006977710650566631954",
"81234880673210146739058568557934581403627822703280",
"82616570773948327592232845941706525094512325230608",
"22918802058777319719839450180888072429661980811197",
"77158542502016545090413245809786882778948721859617",
"72107838435069186155435662884062257473692284509516",
"20849603980134001723930671666823555245252804609722",
"53503534226472524250874054075591789781264330331690"
];

mid = [ [/*1~10의 자리*/], [/*11~20의 자리*/], [/*21~30의 자리*/], [/*31~40의 자리*/], [/*41~50의 자리*/] ];
for (i = 0 ; i < input.length ; i++) {
	mid[0].push(parseInt(input[i].substr(40,10)));
	mid[1].push(parseInt(input[i].substr(30,10)));
	mid[2].push(parseInt(input[i].substr(20,10)));
	mid[3].push(parseInt(input[i].substr(10,10)));
	mid[4].push(parseInt(input[i].substr(0,10)));
}

sum = next = 0;
for ( i = 0 ; i < mid.length ; i++){
	sum = next;
	for ( j = 0 ; j < mid[i].length ; j++)
		sum += mid[i][j];
	next = (sum - sum % 1E10 ) / 1E10;
}
console.log(sum);

}



================================================================================

Problem 14
출제 일시 : 2012-01-03 19:11:35

양의 정수 n에 대하여, 다음과 같은 계산 과정을 반복하기로 합니다.

n → n / 2 (n이 짝수일 때)
n → 3 n + 1 (n이 홀수일 때)

13에 대하여 위의 규칙을 적용해보면 아래처럼 10번의 과정을 통해 1이 됩니다.

13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
아직 증명은 되지 않았지만, 이런 과정을 거치면 어떤 수로 시작해도 마지막에는 1로 끝나리라 생각됩니다. 
(역주: 이것은 콜라츠 추측 Collatz Conjecture이라고 하며, 이런 수들을 우박수 hailstone sequence라 부르기도 합니다)

그러면, 백만(1,000,000) 이하의 수로 시작했을 때 1까지 도달하는데 가장 긴 과정을 거치는 숫자는 얼마입니까?

참고: 계산 과정 도중에는 숫자가 백만을 넘어가도 괜찮습니다.


{ // Problem 14 - 837799
// JavaScript

// memorizing & recursion - 4413 ms
now = performance.now();
list = [0,0], result = [1,0];
function hailstone(n){
	if (list.hasOwnProperty(n)) return list[n];
	else if ( n % 2 ) return 1 + hailstone(3 * n + 1);
	else return 1 + hailstone(n / 2);
}
for (i=2; i<=1E6;i++){
	list[i] = hailstone(i);
	if (result[1] < list[i]) result = [i, list[i]];
}
console.log(result[0]);
console.log(performance.now() - now);


// iterative & no memorize - 5218 ms
now = performance.now();
result = 1, maxcount=0;
function hailstone(n){
	count = 0;
	while(n>1){
		count++;
		if ( n % 2 ) n=3*n+1;
		else n/=2;
	}
	return count;
}
for (i=2; i<=1E6;i++){
	count = hailstone(i);
	if (maxcount < count) {
		result = i;
		maxcount = count;
	}
}
console.log(result);
console.log(performance.now() - now);

// iterative & no memorize & inline - 230587 ms
now = performance.now();
var count, n, result = 1, maxcount=0;
for (var i=2; i<=1E6;i++){
	count = 0, n=i;
	while(n>1){
		count++;
		if ( n % 2 ) n=3*n+1;
		else n/=2;
	}
	if (maxcount < count) {
		result = i;
		maxcount = count;
	}
}
console.log(result);
console.log(performance.now() - now);
}


================================================================================

Problem 15
출제 일시 : 2012-01-03 19:11:35

아래와 같은 2 × 2 격자의 왼쪽 위 모서리에서 출발하여 오른쪽 아래 모서리까지 도달하는 길은 모두 6가지가 있습니다 (거슬러 가지는 않기로 합니다).
그러면 20 × 20 격자에는 모두 몇 개의 경로가 있습니까?

{ // Problem 15 -137846528820
40! / 20! / 20!
}



================================================================================

Problem 16
출제 일시 : 2012-01-03 19:11:35

2^15 = 32768 의 각 자리수를 더하면 3 + 2 + 7 + 6 + 8 = 26 입니다.
2^1000의 각 자리수를 모두 더하면 얼마입니까?


{ // Problem 16 - 1366
해당 PL이 허용하는 범위 내에서 뒷자리부터 끊어서 연산한다.
편의상 10자리씩 끊는다. 이후 몫을 다음 자릿수 연산에 더하면 된다.

// JavaScript

prod = [[1]];
quotient = next = result = 0;
for ( i = 0 ; i < 1000 ; i++){
	next = 0;
	for ( j = 0 ; j < prod.length ; j++){
		prod[j] *= 2;
		prod[j] += next;
		next = (prod[j] - prod[j] % 1E10) / 1E10;
		prod[j] = prod[j] % 1E10;
	}
	if (prod[prod.length-1] > 0) prod.push([0]);
}
for ( i = 0 ; i < prod.length ; i++){
	temp = prod[i];
	while ( temp > 0 ){
		result += temp % 10;
		temp = (temp - temp % 10) / 10;
	}
}
console.log(result);

}

================================================================================

Problem 17
출제 일시 : 2012-01-03 19:11:35

1부터 5까지의 숫자를 영어로 쓰면 one, two, three, four, five 이고,
각 단어의 길이를 더하면 3 + 3 + 5 + 4 + 4 = 19 이므로 사용된 글자는 모두 19개입니다.

1부터 1,000까지 영어로 썼을 때는 모두 몇 개의 글자를 사용해야 할까요?

참고: 빈 칸이나 하이픈('-')은 셈에서 제외하며, 단어 사이의 and 는 셈에 넣습니다.
  예를 들어 342를 영어로 쓰면 three hundred and forty-two 가 되어서 23 글자,
  115 = one hundred and fifteen 의 경우에는 20 글자가 됩니다.

  
{ // Problem 17 - 
// digit = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
// teen = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];
//ty = [0,0,'twenty', 'thirty', 'fourty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
//other = ['hundred', 'thousand', 'and'];
digit = [4, 3, 3, 5, 4, 4, 3, 5, 5, 5];
teen = [3, 6, 6, 8, 8, 7, 7, 9, 8, 8];
ty = [0,0,6, 6, 6, 5, 5, 7, 6, 6];
other = [7, 8, 3];

result = 0;
for ( i = 1 ; i < 1001 ; i++){
	if ( i > 999 ) result += other[1];
	else if ( i > 100 ) {
		result += other[0];
		result += digit[(i - i % 100)/100];
		if ( i % 100 > 0 ) {
			result += other[2];
		}
	}
	if ( i % 100 > 0){
		
	}
}






}






















